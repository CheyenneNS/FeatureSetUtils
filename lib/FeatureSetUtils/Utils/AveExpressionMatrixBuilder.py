import json
import time
import uuid

from installed_clients.DataFileUtilClient import DataFileUtil
from installed_clients.KBaseReportClient import KBaseReport
from installed_clients.WorkspaceClient import Workspace as Workspace


def log(message, prefix_newline=False):
    """Logging function, provides a hook to suppress or redirect log messages."""
    print(('\n' if prefix_newline else '') + '{0:.2f}'.format(time.time()) + ': ' + str(message))


class AveExpressionMatrixBuilder:

    def _validate_calculate_average_expression_matrix_params(self, params):
        """
        _validate_calculate_average_expression_matrix_params:
                validates params passed to calculate_average_expression_matrix method
        """

        log('start validating calculate_average_expression_matrix params')

        # check for required parameters
        for p in ['expression_matrix_ref', 'output_suffix', 'workspace_name']:
            if p not in params:
                raise ValueError('"{}" parameter is required, but missing'.format(p))

    def _generate_report(self, expression_matrix_ref, workspace_name):
        """
        _generate_report: generate report
        """

        objects_created = [{'ref': expression_matrix_ref,
                            'description': 'Average ExpressionMatrix'}]

        report_params = {'message': '',
                         'workspace_name': workspace_name,
                         'objects_created': objects_created,
                         # 'html_links': output_html_files,
                         # 'direct_html_link_index': 0,
                         'html_window_height': 366,
                         'report_object_name': 'kb_ave_expr_matrix_report_' + str(uuid.uuid4())}

        kbase_report_client = KBaseReport(self.callback_url, token=self.token)
        output = kbase_report_client.create_extended_report(report_params)

        report_output = {'report_name': output['name'], 'report_ref': output['ref']}

        return report_output

    def _save_expression_matrix(self, em_data, em_obj_name, workspace_name):
        """
        _save_expression_matrix: saving ExpressionMatrix
        """

        try:
            log('saving ExpressionMatrix [{}]'.format(em_obj_name))
        
            data_type = 'KBaseFeatureValues.ExpressionMatrix'
            obj_info = self.dfu.save_objects({'id': self.dfu.ws_name_to_id(workspace_name),
                                              'objects': [{'type': data_type,
                                                           'data': em_data,
                                                           'name': em_obj_name}]})[0]
        except Exception as e:
            log(e)
            raise Exception('Failed Saving ExpressionMatrix to Workspace')

        expression_matrix_ref = str(obj_info[6]) + '/' + str(obj_info[0]) + '/' + str(obj_info[4])

        return expression_matrix_ref

    def __init__(self, config):
        self.ws_url = config["workspace-url"]
        self.callback_url = config['SDK_CALLBACK_URL']
        self.token = config['KB_AUTH_TOKEN']
        self.shock_url = config['shock-url']
        self.ws = Workspace(self.ws_url, token=self.token)
        self.dfu = DataFileUtil(self.callback_url)
        self.scratch = config['scratch']

    def calculate_average_expression_matrix(self, params):
        """
        calculate_average_expression_matrix: create an average ExpressionMatrix object 
                                             from a ExpressionMatrix object

        required params:
        expression_matrix_ref: ExpressionMatrix object reference
        output_suffix: output average ExpressionMatrix name suffix
        workspace_name: the name of the workspace it gets saved to
        
        return:
        average_expression_matrix_ref: generated average ExpressionMatrix object reference
        report_name: report name generated by KBaseReport
        report_ref: report reference generated by KBaseReport
        """

        log('--->\nrunning AveExpressionMatrixBuilder.calculate_average_expression_matrix\n' +
            'params:\n{}'.format(json.dumps(params, indent=1)))

        self._validate_calculate_average_expression_matrix_params(params)

        expression_matrix_ref = params.get('expression_matrix_ref')
        expression_matrix = self.ws.get_objects2({'objects':
                                                  [{'ref': 
                                                    expression_matrix_ref}]})['data'][0]

        expression_matrix_data = expression_matrix['data']
        expression_matrix_info = expression_matrix['info']

        condition_map = expression_matrix_data['condition_mapping']

        ori_data = expression_matrix_data['data']
        ori_col_ids = ori_data['col_ids']
        ori_row_ids = ori_data['row_ids']
        ori_values = ori_data['values']

        labels = list(condition_map.keys())

        if set(labels) != set(ori_col_ids):
            error_msg = 'available labels: {}\n'.format(ori_col_ids)
            error_msg += 'labels in condition_mapping: {}'.format(labels)
            raise ValueError(error_msg)

        condition_pos = {}

        for label, condition in condition_map.items():
            if condition not in condition_pos:
                condition_pos.update({condition: [ori_col_ids.index(label)]})
            else:
                condition_list = condition_pos[condition]
                condition_list.append(ori_col_ids.index(label))
                condition_pos.update({condition: condition_list})

        conditions = list(condition_pos.keys())

        ave_values = []
        for ori_value in ori_values:
            ave_value = [None] * len(conditions)
            for condition, poss in condition_pos.items():
                ave_pos = conditions.index(condition)
                sum_value = 0.0
                for pos in poss:
                    sum_value += round(float(ori_value[pos]), 3) 
                average = sum_value / len(poss)
                ave_value[ave_pos] = round(average, 2)

            ave_values.append(ave_value)

        average_data = {}
        average_data.update({'row_ids': ori_row_ids})
        average_data.update({'col_ids': conditions})
        average_data.update({'values': ave_values})

        em_data = {}
        genome_ref = expression_matrix_data.get('genome_ref')
        if genome_ref:
            em_data.update({'genome_ref': genome_ref})
        em_data.update({'scale': expression_matrix_data.get('scale')})
        em_data.update({'type': expression_matrix_data.get('type')})
        em_data.update({'feature_mapping': expression_matrix_data.get('feature_mapping')})
        em_data.update({'condition_mapping': expression_matrix_data.get('condition_mapping')})
        em_data.update({'data': average_data})

        expression_matrix_name = expression_matrix_info[1]
        ave_expression_matrix_name = expression_matrix_name + params.get('output_suffix')

        workspace_name = params.get('workspace_name')

        ave_expression_matrix_ref = self._save_expression_matrix(em_data, 
                                                                 ave_expression_matrix_name, 
                                                                 workspace_name)

        returnVal = {'average_expression_matrix_ref': ave_expression_matrix_ref}

        report_output = self._generate_report(ave_expression_matrix_ref,
                                              workspace_name)
        returnVal.update(report_output)

        return returnVal
